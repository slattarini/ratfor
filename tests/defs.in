#!/bin/sh
# $Id$
# Common definitions and environments setting read (with the `source'
# shell builtin) by all tests of ratfor.
#
# This file is heavily based on automake's own `tests/defs.in', so it
# must be released under the GNU General Public License, version 2 or
# later. For more info, see  <http://www.gnu.org/licenses/>.
#

# Shell initialization code, stolen from autoconf
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
    case `(set -o) 2>/dev/null` in
        *posix*) set -o posix;;
              *) ;;
    esac
fi
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
(set -u) >/dev/null 2>&1 && set -u

case "${RAT4_TESTSUITE_FORCE_BIN_SH-}" in
    y|Y|yes|Yes|YES|1)
        # go ahead with the current shell
        ;;
    *)
        # Be sure to run with the best shell found by configure
        if test -n "${__RAT4_TESTSUITE_RERUN_WITH_CONFIG_SHELL__-}"; then
            : # go ahead
        else
            __RAT4_TESTSUITE_RERUN_WITH_CONFIG_SHELL__=yes
            export __RAT4_TESTSUITE_RERUN_WITH_CONFIG_SHELL__
            exec $SHELL "$0" ${1+"$@"}
            exit 255 # NOTREACHED
        fi
        ;;
esac

# Configured data, metadata and testing tools.
PACKAGE_VERSION='@PACKAGE_VERSION@'
PACKAGE_NAME='@PACKAGE_NAME@'
EXEEXT='@EXEEXT@'
GREP=${RAT4_TESTSUITE_GREP-'@GREP@'}
EGREP=${RAT4_TESTSUITE_EGREP-'@EGREP@'}
FGREP=${RAT4_TESTSUITE_FGREP-'@FGREP@'}
SED=${RAT4_TESTSUITE_SED-'@SED@'}
AWK=${RAT4_TESTSUITE_AWK-'@AWK@'}
SHELL=${RAT4_TESTSUITE_SHELL-'@SHELL@'}
DIFF_U=${RAT4_TESTSUITE_DIFF_U-'@DIFF_U@'}
RAT4_TESTSUITE_F77=${RAT4_TESTSUITE_F77-'@RAT4_TESTSUITE_F77@'}

# Symbolic names for exit statuses
SUCCESS=0
FAILURE=1
E_SKIP=77 # test case skipped
E_HARD=99 # test case aborted due to some "hard error"

case "${RAT4_TESTSUITE_BYPASS_SANITY_CHECKS-}" in
    y|Y|yes|Yes|YES|1) do_sanity_checks() { return 1; };;
                    *) do_sanity_checks() { return 0; };;
esac

# Make errors fatal.
set -e

# Used as a "fingerprint" to identify this file
RAT4_TESTSUITE_DEFS_ID='$Id$'

if do_sanity_checks; then
    # Ensure we are running from the right directory.
    test -f ./defs.sh || {
        echo "defs.sh: not found in current directory" >&2
        exit 1
    }
    $FGREP "$RAT4_TESTSUITE_DEFS_ID" ./defs.sh >/dev/null || {
        echo "defs.sh: does not contain expected \$Id\$ string:" >&2
        echo "         $RAT4_TESTSUITE_DEFS_ID" >&2
        exit 1
    }
fi

test -n "${srcdir-}" || {
   # compute $srcdir
   srcdir=`echo x"$0" | $SED -e 's/^x//' -e 's|/[^/]*$||'`
   test x"$srcdir" != x"$0" || srcdir=.
}

if do_sanity_checks; then
    # ensure $srcdir is set correctly
    test -f "$srcdir/defs.in" || {
        echo "$srcdir/defs.in: not found." >&2
        echo "Please check \$srcdir." >&2
        exit 1
    }
    $FGREP "$RAT4_TESTSUITE_DEFS_ID" "$srcdir/defs.in" >/dev/null || {
        echo "$srcdir/defs.in: does not contain expected \$Id\$ string:">&2
        echo "                 $RAT4_TESTSUITE_DEFS_ID" >&2
        echo "Please check \$srcdir." >&2
        exit 1
    }
fi

# Name of the running test script.
me=`echo x/"$0" | $SED -e 's|.*/||' -e 's/\.test$//'`

# Always use an absolute srcdir.  Otherwise symlinks made in subdirs
# of the test dir just won't work.
case "$srcdir" in
    /*) ;; # OK
     *) srcdir=`cd "$srcdir" && pwd`;;
esac

# Absolute path of the directory where the test is run.
curdir=`pwd`

# Program to be tested
RATFOR=${RAT4_TESTUITE_RATFOR_EXECUTABLE-"$curdir/ratfor${EXEEXT}"}
if do_sanity_checks; then
    test -f "$RATFOR" || {
        echo "expected ratfor program to test not found: $RATFOR" >&2
        exit 1
    }
    test -x "$RATFOR" || {
        echo "expected ratfor program to test not executable: $RATFOR" >&2
        exit 1
    }
fi

# Symbolic names for whitespace characters
SPACE=' '
TAB='	'
NEWLINE='
'
# Some shorthands for common sed regexps and commands.
ws="[${SPACE}${TAB}]"
ws0p="${ws}*" # zero or more white spaces
ws1p="${ws}${ws0p}" # one or more white spaces
# strip leading and trailing white spaces from input
ws_strip() { $SED -e "s/^$ws0p//" -e "s/$ws0p$//"; }
# convert any sequence of tab and space chars to a single space char,
# and strip leading and trailing white spaces
ws_normalize() { $SED -e "s/$ws1p/ /g" -e "s/^ *//" -e "s/ *$//"; }

# We use a trap below for cleanup.  This requires us to go through
# hoops to get the right exit status transported through the signal.
# So use `Exit STATUS' instead of `exit STATUS' inside of the tests.
# Turn off errexit here so that we don't trip the bug with OSF1/Tru64
# sh inside this function.
Exit() {
  set +e
  (exit $1)
  exit $1
}

# Usage: testcase_SKIP [WHY]
# Cause the current testcase to be SKIP'd, explaining why.
testcase_SKIP() {
    test $# -eq 0 || echo "$me: SKIPPED: $*"
    Exit $E_SKIP
}

# Usage: testcase_SKIP [WHY]
# Cause the current testcase to be aborted with an "hard error",
# explaining why.
testcase_HARDERROR() {
    test $# -eq 0 || echo "$me: HARD ERROR: $*"
    Exit $E_HARD
}

# Check that we have a valid fortran 77 compiler available, else 
# cause the testcase to be SKIP'd
require_fortran_compiler() {
    [ -n "$RAT4_TESTSUITE_F77" ] || \
      testcase_SKIP "Fotran 77 compiler not available" \
                    "(variable \`\$RAT4_TESTSUITE_F77' is empty"
}

# "Safer" version of `rm -rf', useful for directories which are either
# unwritable or have unwritable subdirectories.
rm_rf() {
    test $# -gt 0 || return 0  # do nothing if no argument is given
    # the only interesting exit status is that of rm(1): ignore errors
    # in find(1)
    if test -d "$1"; then
        find "$1" -type d '!' -perm -200 -exec chmod u+w {} ";" || :
    fi
    rm -rf "$1"
}

# Invert exit status of the given command
NOT() {
    test $# -gt 0 || set ':'
    if "$@"; then
        return 1
    else
        return 0
    fi
}

# run_CMD COMMAND [-e STATUS] [-i FILE] [ARGUMENTS..]
# ---------------------------------------------------
# Run the given COMMAND (can be a shell function or shell builtin) with
# ARGUMENTS (and with standard input taken from FILE, if option `-i' is
# given), and fail if it does not exit with STATUS (default: 0). Note
# that if status is VOID or IGNORE, any exit value of the command will
# be acceptable.
# Also, save standard output and standard error from the COMMAND
# respectively in files `stdout' and `stderr'.
run_CMD() {
    # not to be diplayed even when `set -x' is active
    { _run_prev_dollarminus=$-; set +x; } 2>/dev/null
    case ${_run_prev_dollarminus} in
        *x*) _run_reset_x='set -x';;
          *) _run_reset_x=':';;
    esac
    _run_stdin=-
    _run_expected_exitcode=0
    _run_cmd=$1
    shift
    while test $# -gt 0; do
        case "$1" in
            -e) _run_expected_exitcode=$2; shift;;
            -i) _run_stdin=$2; shift;;
            --) shift; break;;
             *) break;;
        esac
        shift
    done
    _run_exitcode=0
    case "${_run_stdin}" in
      -)
        "${_run_cmd}" ${1+"$@"} >stdout 2>stderr || \
            _run_exitcode=$?;;
      *)
        "${_run_cmd}" ${1+"$@"} <"${_run_stdin}" >stdout 2>stderr || \
            _run_exitcode=$?;;
    esac
    echo "=== stderr" >&2
    cat stderr >&2
    echo "=== stdout"
    cat stdout
    echo "==="
    case ${_run_expected_exitcode} in
        VOID|void|IGNORE|ignore|"${_run_exitcode}") _run_rc=0;;
        *) _run_rc=1;;
    esac
    ${_run_reset_x}
    # not to be diplayed even when `set -x' is active
    { return ${_run_rc}; } 2>/dev/null
}

# Usage: run_RATFOR [-e STATUS] [-i INFILE] [ARGUMENTS..]
# See documentation of `run_CMD()' for more info.
run_RATFOR() {
    run_CMD $RATFOR ${1+"$@"}
}

# Usage: run_FORTRAN [-e STATUS] [ARGUMENTS..]
# See documentation of `run_CMD()' for more info.
run_F77() {
    run_CMD "$RAT4_TESTSUITE_F77" ${1+"$@"}
}


# Setup cleanup trap
sh_errexit_works='@SH_ERREXIT_WORKS@'
if test x"$sh_errexit_works" = x"yes"; then
    trap '
        rat4_testcase_exit_status=$?
        set +e
        cd "$curdir"
        case $rat4_testcase_exit_status,${keep_testdirs-} in
            0,|0,[nN]|0,[Nn][Oo]) rm_rf ${testSubDir-};;
        esac
        test x"$rat4_testcase_signal" != x"0" && 
          echo "$me: caught signal $rat4_testcase_signal"
        echo "$me: exit $rat4_testcase_exit_status"
        exit $rat4_testcase_exit_status
  ' 0
  for sig in 1 2 13 15; do
    trap 'rat4_testcase_signal='$sig'; { Exit 1; }' $sig
  done
  unset sig
fi
rat4_testcase_signal=0

testSubDir=$me.dir
rm_rf $testSubDir
mkdir $testSubDir
cd ./$testSubDir

echo "=== Running test $0"

# Turn on shell traces.
set -x

pwd

# vim: ft=sh ts=4 sw=4 et
