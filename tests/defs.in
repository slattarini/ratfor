#!/bin/sh
# Common definitions and environments setting read (with the `source'
# shell builtin) by all tests of ratfor.
#

# Shell initialization code, stolen from autoconf
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
    case `(set -o) 2>/dev/null` in
        *posix*) set -o posix;;
              *) ;;
    esac
fi
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
(set -u) >/dev/null 2>&1 && set -u

# NLS nuisances: we want to run in plain C locale, for repeatibility
LC_ALL=C; export LC_ALL
LANGUAGE=C; export LANGUAGE
LANG=C; export LANG

# Configured data, metadata and testing tools.
PACKAGE_VERSION='@PACKAGE_VERSION@'
PACKAGE_NAME='@PACKAGE_NAME@'
EXEEXT='@EXEEXT@'
GREP=${RAT4_TESTSUITE_GREP-'@GREP@'}
EGREP=${RAT4_TESTSUITE_EGREP-'@EGREP@'}
FGREP=${RAT4_TESTSUITE_FGREP-'@FGREP@'}
SED=${RAT4_TESTSUITE_SED-'@SED@'}
AWK=${RAT4_TESTSUITE_AWK-'@AWK@'}
SHELL=${RAT4_TESTSUITE_SHELL-'@SHELL@'}
DIFF_U=${RAT4_TESTSUITE_DIFF_U-'@DIFF_U@'}
F77=${RAT4_TESTSUITE_F77-'@RAT4_TESTSUITE_F77@'}

# Symbolic names for exit statuses
SUCCESS=0
FAILURE=1
E_SKIP=77 # test case skipped
E_HARD=99 # test case aborted due to some "hard error"

# Make errors fatal.
set -e

#
# By default, the test scripts are run with the /bin/sh shell, but this
# might be a rather limited shell. And in this case, configure probably
# detected a better shell and saved it in the AC_SUBST'd variable $SHELL.
# So let's by default rerun with the shell in $SHELL, just to be safe.
# However, if the user know in advance that the shell used to run the
# test scripts is good enough, he can prevent the re-execution of the
# scripts with $SHELL by adding the following definiton to the environment:
#  RAT4_TESTSUITE_RUNNING_WITH_CONFIG_SHELL=yes
#
case "${RAT4_TESTSUITE_RUNNING_WITH_CONFIG_SHELL-}" in
    y|Y|yes|Yes|YES|1)
        : # go ahead with the current shell
        ;;
    *)
        RAT4_TESTSUITE_RUNNING_WITH_CONFIG_SHELL=yes
        export RAT4_TESTSUITE_RUNNING_WITH_CONFIG_SHELL
        exec $SHELL "$0" ${1+"$@"}
        exit $E_HARD # NOTREACHED
        ;;
esac

case "${RAT4_TESTSUITE_BYPASS_SANITY_CHECKS-}" in
    y|Y|yes|Yes|YES|1) do_sanity_checks() { return 1; };;
                    *) do_sanity_checks() { return 0; };;
esac

# In a test script, it is an error if any command which must read from
# standard input does so without first redirecting it; so close stdin
# to make such an error stick out clearly.
exec <&-

if do_sanity_checks; then
    # Ensure we are running from the right directory.
    test -f ./defs.sh || {
        echo "defs.sh: not found in current directory" >&2
        exit $E_HARD
    }
fi

test -n "${srcdir-}" || {
   # compute $srcdir
   srcdir=`echo x"$0" | $SED -e 's/^x//' -e 's|/[^/]*$||'`
   test x"$srcdir" != x"$0" || srcdir=.
}

if do_sanity_checks; then
    # ensure $srcdir is set correctly
    test -f "$srcdir/defs.in" || {
        echo "$srcdir/defs.in: not found." >&2
        echo "Please check \$srcdir." >&2
        exit $E_HARD
    }
fi

# Name of the running test script.
me=`echo x/"$0" | $SED -e 's|.*/||' -e 's/\.test$//'`

# Always use an absolute srcdir.  Otherwise symlinks made in subdirs
# of the test dir just won't work.
case "$srcdir" in
    /*) ;; # OK
     *) srcdir=`cd "$srcdir" && pwd`;;
esac

# Absolute path of the directory where the test is run.
testrootdir=`pwd`

# Program to be tested
RATFOR=${RAT4_TESTUITE_RATFOR_EXECUTABLE-"$testrootdir/ratfor${EXEEXT}"}
if do_sanity_checks; then
    test -f "$RATFOR" || {
        echo "Expected ratfor program to test not found: $RATFOR" >&2
        exit $E_HARD
    }
    test -x "$RATFOR" || {
        echo "Expected ratfor program to test not executable: $RATFOR" >&2
        exit $E_HARD
    }
fi

# Symbolic names for whitespace characters
SPACE=' '
TAB='	'
NEWLINE='
'

# Some shorthands for common sed regexps and commands.
ws="[${SPACE}${TAB}]"
ws0p="${ws}*" # zero or more white spaces
ws1p="${ws}${ws0p}" # one or more white spaces
# strip leading and trailing white spaces from input
ws_strip() { $SED -e "s/^$ws0p//" -e "s/$ws0p$//"; }
# convert any sequence of tab and space chars to a single space char,
# and strip leading and trailing white spaces
ws_normalize() { $SED -e "s/$ws1p/ /g" -e "s/^ *//" -e "s/ *$//"; }

# We use a trap for cleanup.  This requires us to go through hoops to
# get the right exit status transported through signals.  Also, more
# hoops are required since there are shells (even some modern version
# of Bash, e.g. bash-3.2 or bash-4.0) which do not passes a "failure"
# exit status to the exit trap when a syntax error is found.  Sigh.
# So use `Exit STATUS' instead of `exit STATUS' inside the tests.

# Wrapper around exit, needed to pass the correct exit status to the
# exit trap (see `cleanup_at_exit()') below.
Exit() {
    set +e
    rat4_exit_default=$1
    (exit $1); exit $1
}

# Our exit trap: should deal with normal termination, signals,
# untrapped failures and internal errors.
cleanup_at_exit() {
    rat4_exit_status=$?
    set +e
    if test -n "${rat4_exit_signal-}"; then
        echo "$me: caught signal $rat4_exit_signal"
        rat4_exit_status=$E_HARD
    elif test -z "${rat4_exit_default-}"; then
        echo "$me: internal error or untrapped failure"
        rat4_exit_status=$E_HARD
    elif test x"$rat4_exit_default" != x"$rat4_exit_status"; then
        echo "$me: exit status mismatch"
        rat4_exit_status=$E_HARD
    fi
    case $rat4_exit_status,${keep_testdirs-} in
        0,|0,n|0,no|0,NO) rm_rf ${testSubDir-};;
    esac
    echo "$me: exit $rat4_exit_status"
    exit $rat4_exit_status
}

# Usage: testcase_PASS
# Cause the current testcase to terminate with success.
testcase_PASS() {
    Exit $SUCCESS
}

# Usage: testcase_FAIL [WHY]
# Cause the current testcase to terminate with failure, explaining
# the cause of failure if WHY argument is given.
testcase_FAIL() {
    test $# -eq 0 || echo "$me: FAIL: $*"
    Exit $FAILURE
}

# Usage: testcase_SKIP [WHY]
# Cause the current testcase to be SKIP'd, explaining why.
testcase_SKIP() {
    test $# -eq 0 || echo "$me: SKIPPED: $*"
    Exit $E_SKIP
}

# Usage: testcase_SKIP [WHY]
# Cause the current testcase to be aborted with an "hard error",
# explaining why.
testcase_HARDERROR() {
    test $# -eq 0 || echo "$me: HARD ERROR: $*" >&2
    Exit $E_HARD
}

# Check that we have a valid fortran 77 compiler available, else 
# cause the testcase to be SKIP'd.
require_fortran_compiler() {
    case "$F77" in
        "") testcase_SKIP "Fotran 77 compiler not available" \
                          "(variable \`\$F77' is empty)";;
      NONE) testcase_SKIP "Fotran 77 compiler should not be used" \
                          "(variable \`\$F77' is set to \`NONE')";;
    esac
}

# Check that we have available a valid fortran 77 compiler without silly
# limits, else cause the testcase to be SKIP'd.
require_strong_fortran_compiler() {
    require_fortran_compiler
    f77check_opwd=`pwd`
    f77check_ok=no
    mkdir f77check.d \
      && cd f77check.d \
      && $AWK 'BEGIN {
            print "      program testf77"
            for(i = 1; i <= 8192; i++)
                printf("%-5d i%d = 1\n", i, i)
            print "      stop"
            print "      end"
        }'> f77check.f </dev/null \
      && "$F77" -o f77check.exe f77check.f \
      && f77check_ok=yes
    cd "$f77check_opwd"
    rm_rf f77check.d
    if test x"$f77check_ok" = x"no"; then
        testcase_SKIP "Fotran 77 compiler \`$F77' is too limited"
    fi
}

# "Safer" version of `rm -rf', useful for directories which are either
# unwritable or have unwritable subdirectories.
rm_rf() {
    test $# -gt 0 || return 0  # do nothing if no argument is given
    # the only interesting exit status is that of rm(1): ignore errors
    # in find(1)
    if test -d "$1"; then
        find "$1" -type d '!' -perm -200 -exec chmod u+w {} ";" || :
    fi
    rm -rf "$1"
}

# run_CMD COMMAND [-e STATUS] [-i FILE] [-m] [--] [ARGUMENTS..]
# -------------------------------------------------------------
# Run the given COMMAND (can be an external commnds, a shell function or
# shell builtin) with ARGUMENTS (and with standard input taken from FILE,
# if option `-i' is given), and fail if COMMAND does not exit with STATUS.
# If status is "VOID" or "IGNORE", any exit value of the command is
# acceptable.  If STATUS is "FAIL", then any exit value of the command
# *but 0* is acceptable.  Default STATUS is "IGNORED".
# Also, save standard output and standard error from COMMAND, by default
# respectively in files `stdout' and `stderr' (in the current directory),
# or togheter in the file `stdall' (in the current directory) if the `-m'
# option is given.  All the redirections are done without triggering the
# zsh4 bug related to `-x' shell switch (described in details in the
# tests/README file).
run_CMD ()
{
    # NOTE: all internal variables used here starts with the `_run' prefix,
    # to minimize possibility of name clashes with global variables defined
    # in user code.
    : 'entering run_CMD(): become quiet'
    set +x # xtrace verbosity stops here
    case $# in
        0) testcase_HARDERROR "run_CMD(): missing COMMAND argument";;
        *) _run_cmd=$1; shift;;
    esac
    _run_stdin=-
    _run_expected_exitcode=0
    _run_mix_stdout_and_stderr=no
    while test $# -gt 0; do
        case "$1" in
            -e) _run_expected_exitcode=$2; shift;;
            -i) _run_stdin=$2; shift;;
            -m) _run_mix_stdout_and_stderr=yes;;
            --) shift; break;;
            -?) testcase_HARDERROR "run_CMD(): invalid switch '$1'";;
             *) break;;
        esac
        shift
    done
    _run_exitcode=0
    if test x"${_run_mix_stdout_and_stderr}" = x"yes"; then
        _run_evald_cmd='"${_run_cmd}" ${1+"$@"} >stdall 2>&1'
    else
        _run_evald_cmd='"${_run_cmd}" ${1+"$@"} >stdout 2>stderr'
    fi
    if test x"${_run_stdin}" != x"-"; then
        _run_evald_cmd="${_run_evald_cmd}"' <"${_run_stdin}"'
    fi
    _run_evald_cmd="${_run_evald_cmd} || _run_exitcode=\$?"
    eval "${_run_evald_cmd}"
    if test x"${_run_mix_stdout_and_stderr}" = x"yes"; then
        echo "=== stdout and stderr"
        cat stdall
        echo "==="
    else
        echo "=== stderr"
        cat stderr
        echo "=== stdout"
        cat stdout
        echo "==="
    fi
    case ${_run_expected_exitcode} in
        VOID|void|IGNORE|ignore|${_run_exitcode})
            _run_rc=0
            ;;
        FAIL|fail|FAILURE|failure)
            test ${_run_exitcode} -gt 0 && _run_rc=0 || _run_rc=1
            ;;
        *)
            _run_rc=1
            ;;
    esac
    set -x # xtrace verbosity restart here
    : "exit status ${_run_exitcode} (expecting ${_run_expected_exitcode})"
    : "leaving run_CMD()"
    return ${_run_rc}
}

# Usage: run_RATFOR [-e STATUS] [-i INFILE] [-m] [ARGUMENTS..]
# See documentation of `run_CMD()' for more info.
run_RATFOR() {
    run_CMD "$RATFOR" ${1+"$@"}
}

# Usage: run_F77 [-e STATUS] [-i INFILE] [-m] [ARGUMENTS..]
# See documentation of `run_CMD()' for more info.
run_F77() {
    run_CMD "$F77" ${1+"$@"}
}

# Usage: timer [-e] TIME COMMAND [ARGS]
# Run the given COMMAND (in a subshell) until the given TIME (measured
# in seconds) is expired, then terminate it.  If `-e' option is given,
# eval COMMAND rather then simply executing it (in this case, no ARGS
# is accepted).  The exit status of COMMAND is saved in the file
# `timer-exitstatus' in the current directory; if the command has timed
# out, that file will contain the string "TIMEOUT".  Return status of
# timer() is 255 if COMMAND timed out, and the return status of COMMAND
# otherwise.
timerExitStatusFile=timer-exitstatus
timer() {
    if test x"${1-}" = x"-e"; then
        _timer_eval=yes
        shift
    else
        _timer_eval=no
    fi
    case $# in
        0) testcase_HARDERROR "timer(): missing TIME argument";;
        1) testcase_HARDERROR "timer(): missing COMMAND argument";;
    esac
    _timer_time=$1
    _timer_cmd=$2
    [ 0 -lt "${_timer_time}" ] || \
      testcase_HARDERROR "timer(): invalid TIME ${_timer_time}"
    shift 2
    if test x"${_timer_eval}" = x"yes" && test $# -gt 0; then
        testcase_HARDERROR "timer(): ARGS not acceptable with \`-e' option"
    fi
    (
      trap '' 3 # ignore SIGQUIT, it will be used to `ping' the process
      echo TIMEOUT >$timerExitStatusFile
      _timer_e=0
      if test x"${_timer_eval}" = x"yes"; then
        eval "${_timer_cmd}" || _timer_e=$?
      else
        "${_timer_cmd}" ${1+"$@"} || _timer_e=$?
      fi
      echo ${_timer_e} >$timerExitStatusFile
    ) & # background
    _timer_pid=$!
    _timer_i=0
    while :; do
        _timer_i=`expr ${_timer_i} + 1`
        kill -3 ${_timer_pid} || break # process finished by itslef
        sleep 1
        if test ${_timer_i} -lt ${_timer_time}; then
            continue
        else
            kill -15 ${_timer_pid} || :
            sleep 3 # give the process the time to die gracefully
            if kill -3 ${_timer_pid}; then
                # sigh, process still alive... and we don't want to leave
                # stray processes lingering around.
                kill -9 ${_timer_pid}
            fi
            break
        fi
    done
    _timer_e=`cat $timerExitStatusFile`
    case ${_timer_e} in
        TIMEOUT) return 255;;
        *) return ${_timer_e};;
    esac
}

# Setup cleanup traps.
trap 'cleanup_at_exit' 0
trap 'rat4_exit_signal=SIGHUP;  Exit $E_HARD' 1
trap 'rat4_exit_signal=SIGINT;  Exit $E_HARD' 2
trap 'rat4_exit_signal=SIGPIPE; Exit $E_HARD' 13
trap 'rat4_exit_signal=SIGTERM; Exit $E_HARD' 15

# Were the tests will run.
rm_rf $me.dir
mkdir $me.dir
cd ./$me.dir
testSubDir=`pwd` # absolute path

echo "=== Running test $0"

# Turn on shell traces.
set -x

pwd

# vim: ft=sh ts=4 sw=4 et
